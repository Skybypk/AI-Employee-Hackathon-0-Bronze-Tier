import os
import sys
import threading
import time
import logging
import json
from pathlib import Path
from datetime import datetime

# Set up logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('ai_employee.log'),
        logging.StreamHandler()
    ]
)

logger = logging.getLogger(__name__)

# Add the project root to the Python path
project_root = Path(__file__).parent
sys.path.insert(0, str(project_root))

from watchers.gmail_watcher import GmailWatcher
from watchers.filedrop_watcher import FileDropWatcher


class Orchestrator:
    def __init__(self, vault_path: str):
        self.vault_path = Path(vault_path)
        self.watchers = []
        self.running = False

        # Create logs directory if it doesn't exist
        logs_dir = self.vault_path / 'Logs'
        logs_dir.mkdir(exist_ok=True)

        # Log file for this session
        self.log_file = logs_dir / f"{datetime.now().strftime('%Y-%m-%d')}_session.json"

    def add_watcher(self, watcher):
        """Add a watcher to the orchestrator"""
        self.watchers.append(watcher)

    def start_watchers(self):
        """Start all registered watchers in separate threads"""
        if self.running:
            logger.warning("Orchestrator is already running")
            return

        self.running = True
        logger.info("Starting AI Employee orchestrator...")

        for watcher in self.watchers:
            thread = threading.Thread(target=watcher.run, daemon=True)
            thread.start()
            logger.info(f"Started watcher: {watcher.__class__.__name__}")

    def stop_watchers(self):
        """Stop all running watchers"""
        self.running = False
        logger.info("Stopping AI Employee orchestrator...")

        # Close Gmail connections if they exist
        for watcher in self.watchers:
            if hasattr(watcher, 'close'):
                watcher.close()

    def monitor_system(self):
        """Monitor the system status and log activities"""
        while self.running:
            # Update dashboard with current status
            self.update_dashboard()

            # Log system status
            self.log_system_status()

            time.sleep(300)  # Update every 5 minutes

    def update_dashboard(self):
        """Update the dashboard with current status"""
        dashboard_path = self.vault_path / 'Dashboard.md'

        # Count pending actions
        needs_action_dir = self.vault_path / 'Needs_Action'
        pending_actions = len(list(needs_action_dir.glob('*.md'))) if needs_action_dir.exists() else 0

        # Count completed actions today
        done_dir = self.vault_path / 'Done'
        today_done = len([f for f in done_dir.glob('*.md') if f.stat().st_mtime > time.time() - 86400]) if done_dir.exists() else 0

        # Read current dashboard content
        if dashboard_path.exists():
            content = dashboard_path.read_text()
        else:
            content = "# AI Employee Dashboard\n\n## Executive Summary\nWelcome to your AI Employee dashboard.\n\n## Current Status\n- **AI Employee**: Offline\n- **Last Activity**: Never\n- **Active Watchers**: 0\n- **Pending Actions**: 0\n\n## Recent Activity\n- [Never] System not initialized\n\n## Key Metrics\n- **Tasks Processed**: 0\n- **Messages Handled**: 0\n- **Revenue Tracked**: $0.00\n\n## Quick Actions\n- [[Company_Handbook]]\n- [[Business_Goals]]\n- [[Needs_Action]]\n- [[Pending_Approval]]\n\n---\n*Generated by AI Employee v0.1*"

        # Update the dashboard content
        lines = content.split('\n')
        updated_lines = []

        for line in lines:
            if line.startswith('- **AI Employee**:'):
                updated_lines.append('- **AI Employee**: Online' if self.running else '- **AI Employee**: Offline')
            elif line.startswith('- **Last Activity**:'):
                updated_lines.append(f'- **Last Activity**: {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}')
            elif line.startswith('- **Active Watchers**:'):
                updated_lines.append(f'- **Active Watchers**: {len(self.watchers)}')
            elif line.startswith('- **Pending Actions**:'):
                updated_lines.append(f'- **Pending Actions**: {pending_actions}')
            elif line.startswith('- [Never] System not initialized') or 'Recent Activity' in line:
                if 'Recent Activity' in line:
                    updated_lines.append(line)
                    status = 'started' if self.running else 'stopped'
                    updated_lines.append(f'- [{datetime.now().strftime("%Y-%m-%d %H:%M")}] System {status}')
                else:
                    # Skip the old initialization line
                    continue
            elif line.startswith('- **Tasks Processed**:'):
                updated_lines.append(f'- **Tasks Processed**: {today_done}')
            else:
                updated_lines.append(line)

        # Write updated content back to file
        dashboard_path.write_text('\n'.join(updated_lines))

    def log_system_status(self):
        """Log system status to the session log file"""
        status = {
            "timestamp": datetime.now().isoformat(),
            "status": "running" if self.running else "stopped",
            "active_watchers": len(self.watchers),
            "pending_actions": len(list((self.vault_path / 'Needs_Action').glob('*.md'))) if (self.vault_path / 'Needs_Action').exists() else 0,
            "completed_today": len([f for f in (self.vault_path / 'Done').glob('*.md') if f.stat().st_mtime > time.time() - 86400]) if (self.vault_path / 'Done').exists() else 0
        }

        # Append to log file
        with open(self.log_file, 'a') as f:
            f.write(json.dumps(status) + '\n')

    def run(self):
        """Run the orchestrator"""
        try:
            self.start_watchers()

            # Start monitoring in a separate thread
            monitor_thread = threading.Thread(target=self.monitor_system, daemon=True)
            monitor_thread.start()

            # Keep the main thread alive
            while self.running:
                time.sleep(1)

        except KeyboardInterrupt:
            logger.info("Received interrupt signal")
        finally:
            self.stop_watchers()


if __name__ == "__main__":
    # Initialize the orchestrator with the vault path
    vault_path = Path("./AI_Employee_Vault")

    orchestrator = Orchestrator(vault_path)

    # Add watchers (these would need proper configuration)
    # For now, we'll show how to add them:

    # Gmail watcher example (would need actual credentials):
    # gmail_watcher = GmailWatcher(
    #     vault_path=vault_path,
    #     email_account=os.getenv("GMAIL_ACCOUNT"),
    #     password=os.getenv("GMAIL_APP_PASSWORD")
    # )
    # orchestrator.add_watcher(gmail_watcher)

    # File drop watcher example:
    # file_watcher = FileDropWatcher(
    #     vault_path=vault_path,
    #     watch_folder="./watch_folder"  # This folder needs to exist
    # )
    # orchestrator.add_watcher(file_watcher)

    print("AI Employee Orchestrator initialized.")
    print("To start the system, uncomment and configure the watchers in orchestrator.py")
    print("Then run: python orchestrator.py")